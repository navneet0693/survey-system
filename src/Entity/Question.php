<?php

namespace App\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\Validator\Context\ExecutionContextInterface;

/**
 * Question Entity.
 *
 * Represents a single question within a survey. Questions can be of different types
 * (single choice, multiple choice)
 * and can have various options for multiple choice questions.
 *
 * Key Features:
 * - Multiple question types with type-specific validation
 * - Optional "other" option for choice questions
 * - Ordered display within surveys
 * - Required/optional question support
 * - Option collection for choice questions
 *
 * Business Rules:
 * - Questions must belong to a survey
 * - Choice questions require at least one option
 * - Questions are ordered by position
 * - Required questions must be answered
 *
 * Relationships:
 * - Many-to-One with Survey entity
 * - One-to-Many with QuestionOption entities
 * - One-to-Many with QuestionResponse entities
 *
 * @author navneet0693
 *
 * @ORM\Entity(repositoryClass="App\Repository\QuestionRepository")
 *
 * @ORM\Table(name="questions")
 */
#[ORM\Entity(repositoryClass: 'App\Repository\QuestionRepository')]
#[ORM\Table(name: 'questions')]
class Question
{
    /**
     * Unique identifier for the question
     * Auto-generated by Doctrine ORM.
     */
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer', nullable: false)]
    private int $id;

    /**
     * The survey this question belongs to
     * Required relationship - questions cannot exist without a survey.
     */
    #[ORM\ManyToOne(targetEntity: Survey::class, inversedBy: 'questions')]
    #[ORM\JoinColumn(nullable: false)]
    private Survey $survey;

    /**
     * The question text displayed to respondents
     * Required field with length validation for UI constraints.
     */
    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank(message: 'Question text is required')]
    #[Assert\Length(
        min: 5,
        max: 500,
        minMessage: 'Question must be at least {{ limit }} characters long',
        maxMessage: 'Question cannot be longer than {{ limit }} characters'
    )]
    private string $questionText;

    /**
     * Type of question (single choice, multiple choice, text, file upload)
     * Determines validation rules and response handling.
     */
    #[ORM\Column(type: 'string', enumType: QuestionType::class)]
    private QuestionType $questionType = QuestionType::SINGLE_CHOICE;

    /**
     * Whether this question must be answered
     * Required questions prevent survey submission if unanswered.
     */
    #[ORM\Column(type: 'boolean')]
    private bool $isRequired = true;

    /**
     * Display order within the survey
     * Used for consistent question ordering.
     */
    #[ORM\Column(type: 'integer')]
    private int $orderPosition = 0;

    /**
     * Timestamp when question was created
     * Auto-set in constructor.
     */
    #[ORM\Column(type: 'datetime')]
    private \DateTime $createdAt;

    /**
     * Collection of options for choice questions
     * Ordered by position for consistent display.
     */
    #[ORM\OneToMany(targetEntity: QuestionOption::class, mappedBy: 'question', cascade: ['persist', 'remove'])]
    #[ORM\OrderBy(['orderPosition' => 'ASC'])]
    private Collection $options;

    /**
     * Constructor initializes collections and timestamps
     * Sets default question type to SINGLE_CHOICE and creates empty options collection.
     */
    public function __construct()
    {
        $this->options = new ArrayCollection();
        $this->createdAt = new \DateTime();
    }

    /**
     * Get the unique identifier of the question.
     *
     * @return int|null The question ID, null if not persisted
     */
    public function getId(): ?int
    {
        return $this->id;
    }

    /**
     * Get the survey this question belongs to.
     *
     * @return Survey The parent survey
     */
    public function getSurvey(): Survey
    {
        return $this->survey;
    }

    /**
     * Set the survey this question belongs to.
     *
     * @param Survey $survey The parent survey
     *
     * @return self For method chaining
     */
    public function setSurvey(Survey $survey): self
    {
        $this->survey = $survey;

        return $this;
    }

    /**
     * Get the question text displayed to respondents.
     *
     * @return string The question text
     */
    public function getQuestionText(): string
    {
        return $this->questionText;
    }

    /**
     * Set the question text.
     *
     * @param string $questionText The question text
     *
     * @return self For method chaining
     */
    public function setQuestionText(string $questionText): self
    {
        $this->questionText = $questionText;

        return $this;
    }

    /**
     * Get the question type.
     *
     * @return QuestionType The question type
     */
    public function getQuestionType(): QuestionType
    {
        return $this->questionType;
    }

    /**
     * Set the question type.
     *
     * @param QuestionType $questionType The question type
     *
     * @return self For method chaining
     */
    public function setQuestionType(QuestionType $questionType): self
    {
        $this->questionType = $questionType;

        return $this;
    }

    /**
     * Check if this question is required.
     *
     * @return bool True if question is required
     */
    public function isRequired(): bool
    {
        return $this->isRequired;
    }

    /**
     * Set whether this question is required.
     *
     * @param bool $isRequired Whether question is required
     *
     * @return self For method chaining
     */
    public function setIsRequired(bool $isRequired): self
    {
        $this->isRequired = $isRequired;

        return $this;
    }

    /**
     * Get the display order position.
     *
     * @return int The order position
     */
    public function getOrderPosition(): int
    {
        return $this->orderPosition;
    }

    /**
     * Set the display order position.
     *
     * @param int $orderPosition The order position
     *
     * @return self For method chaining
     */
    public function setOrderPosition(int $orderPosition): self
    {
        $this->orderPosition = $orderPosition;

        return $this;
    }

    /**
     * Get the creation timestamp.
     *
     * @return \DateTime The creation timestamp
     */
    public function getCreatedAt(): \DateTime
    {
        return $this->createdAt;
    }

    /**
     * Set the creation timestamp.
     *
     * @param \DateTime $createdAt The creation timestamp
     *
     * @return self For method chaining
     */
    public function setCreatedAt(\DateTime $createdAt): self
    {
        $this->createdAt = $createdAt;

        return $this;
    }

    /**
     * Get the collection of options for this question.
     *
     * @return Collection The options collection
     */
    public function getOptions(): Collection
    {
        return $this->options;
    }

    /**
     * Add an option to this question.
     *
     * @param QuestionOption $option The option to add
     *
     * @return self For method chaining
     */
    public function addOption(QuestionOption $option): self
    {
        if (!$this->options->contains($option)) {
            $this->options[] = $option;
            $option->setQuestion($this);
        }

        return $this;
    }

    /**
     * Remove an option from this question.
     *
     * @param QuestionOption $option The option to remove
     *
     * @return self For method chaining
     */
    public function removeOption(QuestionOption $option): self
    {
        if ($this->options->removeElement($option)) {
            if ($option->getQuestion() === $this) {
                $option->setQuestion($this);
            }
        }

        return $this;
    }

    /**
     * Check if this is a choice-based question.
     *
     * Determines if the question type requires predefined options
     * for respondents to select from.
     *
     * @return bool True if question is SINGLE_CHOICE or MULTIPLE_CHOICE
     */
    public function isChoiceQuestion(): bool
    {
        return in_array($this->questionType, [
            QuestionType::SINGLE_CHOICE,
            QuestionType::MULTIPLE_CHOICE,
        ]);
    }

    /**
     * Get option by ID.
     *
     * Searches through the options collection to find an option
     * with the specified ID.
     *
     * @param int $optionId ID of the option to find
     *
     * @return QuestionOption|null The option if found, null otherwise
     */
    public function getOptionById(int $optionId): ?QuestionOption
    {
        foreach ($this->options as $option) {
            if ($option->getId() === $optionId) {
                return $option;
            }
        }

        return null;
    }

    /**
     * Validate if provided option IDs are valid for this question.
     *
     * Checks if all provided option IDs exist in this question's
     * options collection. Used for response validation.
     *
     * @param array $optionIds Array of option IDs to validate
     *
     * @return bool True if all option IDs are valid
     */
    public function validateOptionIds(array $optionIds): bool
    {
        $validOptionIds = $this->options->map(function (QuestionOption $option) {
            return $option->getId();
        })->toArray();

        foreach ($optionIds as $optionId) {
            if (!in_array($optionId, $validOptionIds)) {
                return false;
            }
        }

        return true;
    }
}
